// +build ignore

package main

import (
	"bytes"
	"fmt"
	"github.com/iancoleman/strcase"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
	"github.com/weaveworks/eksctl/pkg/ctl/cmdutils"
	"github.com/weaveworks/eksctl/pkg/ctl/create"
	del "github.com/weaveworks/eksctl/pkg/ctl/delete"
	"github.com/weaveworks/eksctl/pkg/ctl/drain"
	"github.com/weaveworks/eksctl/pkg/ctl/enable"
	"github.com/weaveworks/eksctl/pkg/ctl/generate"
	"github.com/weaveworks/eksctl/pkg/ctl/get"
	"github.com/weaveworks/eksctl/pkg/ctl/scale"
	"github.com/weaveworks/eksctl/pkg/ctl/set"
	"github.com/weaveworks/eksctl/pkg/ctl/unset"
	"github.com/weaveworks/eksctl/pkg/ctl/update"
	"github.com/weaveworks/eksctl/pkg/ctl/upgrade"
	"github.com/weaveworks/eksctl/pkg/ctl/utils"
	"go/format"
	"strings"
	"text/template"
)

const templateString = `

type {{ .CommandNameCamelCase }}Args struct {
    {{ range $key, $value := .CommandArguments }}
        {{ ToCamelCase $key }} string{{ end }}
}

func (b *{{- .CommandNameCamelCase }}Args) buildArgs() []string {
    args := []string {
        {{ range $cmd := .CommandToExecute }}
            "{{ $cmd }}",{{end}}
	}

	v := reflect.ValueOf(b).Elem()

    for i := 0; i < v.NumField(); i++ {
		if v.Field(i).Interface().(string) != "" {
			args = append(args, "--" + strcase.ToKebab(v.Type().Field(i).Name) + "=" + v.Field(i).Interface().(string))
		}
    }

	return args
}

func {{ .CommandNameCamelCase }}(b *{{- .CommandNameCamelCase }}Args, buf *bytes.Buffer) error {
	rootCmd.SetOut(buf)
	rootCmd.SetErr(buf)
	rootCmd.SetArgs(b.buildArgs())
	_, err := rootCmd.ExecuteC()

	return err
}
`

type TemplateArgs struct {
	CommandNameCamelCase string
	CommandArguments     map[string]string
	CommandToExecute     []string
}

// DebugFlags used to determine which flags have been assigned to which commands
// and which persist.
func DebugFlags(c *cobra.Command) {
	var commandName []string
	var commandOptions = make(map[string]string)
	var latestCommandOptions = make(map[string]string)
	var debugFlags func(*cobra.Command)

	debugFlags = func(x *cobra.Command) {
		commandName = append(commandName, x.Name())

		if x.HasFlags() {
			x.Flags().VisitAll(func(f *pflag.Flag) {
				commandOptions[f.Name] = f.DefValue
				latestCommandOptions[f.Name] = f.DefValue
			})
		}
		if x.HasPersistentFlags() {
			x.PersistentFlags().VisitAll(func(f *pflag.Flag) {
				commandOptions[f.Name] = f.DefValue
				latestCommandOptions[f.Name] = f.DefValue
			})
		}
		if x.HasSubCommands() {
			for _, y := range x.Commands() {
				latestCommandOptions = make(map[string]string)
				debugFlags(y)
			}
		} else {
			templateArgs := TemplateArgs{
				CommandNameCamelCase: strcase.ToCamel(strings.Join(commandName[:], " ")),
				CommandArguments:     commandOptions,
				CommandToExecute:     commandName,
			}
			parsedTemplate, err := template.New("template.tpl").Funcs(template.FuncMap{
				"ToCamelCase": strcase.ToCamel,
				"ToLowerCamelCase": strcase.ToLowerCamel,
				"ToKebabCase": strcase.ToKebab,
			}).Parse(templateString)
			var templateBytes bytes.Buffer

			if err != nil {
				panic(err)
			}

			err = parsedTemplate.Execute(&templateBytes, templateArgs)

			if err != nil {
				panic(err)
			}

			p, err := format.Source(templateBytes.Bytes())

			if err != nil {
				panic(err)
			}

			fmt.Println(string(p))
			commandName = commandName[:len(commandName)-1]
			for key := range latestCommandOptions {
				delete(commandOptions, key)
			}
		}
	}

	debugFlags(c)
}

type CreateClusterCommandArgsBuilder interface {
	Region(string) CreateClusterCommandArgsBuilder
}

func main() {
	fmt.Println("// Code generated by go generate; DO NOT EDIT.\n")
	fmt.Println("package aws\n")
	fmt.Println("import \"bytes\"")
	fmt.Println("import \"reflect\"")
	fmt.Println("import \"github.com/iancoleman/strcase\"")

	flagGrouping := cmdutils.NewGrouping()
	DebugFlags(create.Command(flagGrouping))
	DebugFlags(get.Command(flagGrouping))
	DebugFlags(update.Command(flagGrouping))
	DebugFlags(upgrade.Command(flagGrouping))
	DebugFlags(del.Command(flagGrouping))
	DebugFlags(set.Command(flagGrouping))
	DebugFlags(unset.Command(flagGrouping))
	DebugFlags(scale.Command(flagGrouping))
	DebugFlags(drain.Command(flagGrouping))
	DebugFlags(generate.Command(flagGrouping))
	DebugFlags(enable.Command(flagGrouping))
	DebugFlags(utils.Command(flagGrouping))
}
